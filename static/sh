#!/usr/bin/env sh
# -*- mode: sh; -*-
# SPDX-License-Identifier: MPL-2.0

# shellcheck shell=sh enable=check-set-e-suppressed
# shellcheck enable=require-variable-braces
# shellcheck enable=quote-safe-variables

set -eu

# all caps = can come from outside environment
# all lower = internal variable

USER_EMAIL=${USER_EMAIL:-}
DATA_DIR=${DATA_DIR:-"./public"}

ACCOUNT_ID=${CFLARE_ACCOUNT_ID:-}

SCRIPT_NAME=${SCRIPT_NAME:-}

HTML_HANDLING=${HTML_HANDLING:-"drop-trailing-slash"}

# The shellcheck complaint is solved by the sf_curl function
# Or so I think.
# shellcheck disable=2089
CURLFLAGS="${CURLFLAGS:-} -s -H Connection:Keep-alive " # -H 'Connection: keep-alive' "

HASHER=${HASHER:-}

# Used to make temporary files to pass data around.
TMPDIR=${TMPDIR:-}

# Verbosity
V=0

# sh doesn't have lazy eval variables.
# authz_hdr="Authorization: Bearer ${CFLARE_API_KEY}"
authz_hdr=

# Lacks trailing slash so composition is prettier
# ${api_base}/some/api
api_base="https://api.cloudflare.com/client/v4"

manifest='{ "manifest": {} }'

# Safeguard if jq is invoked incorrectly and starts waiting on data from stdin
# This incantation closes the stdin file descriptor.
# This script never reads from stdin!
exec 0<&-

# Wrapper for curl to inject CURLFLAGS
# Who says POSIX SH doesn't have arrays?
# $@ is an ARRAY!
# Wonder if this set -- stuff is safer than just
# having the function be curl ${CURLFLAGS} "$@" ??
sf_curl() {
    # I want this to be word split
    # shellcheck disable=2086
    set -- ${CURLFLAGS} "$@" 
    log "Invoked: curl $*"
    curl "$@" 
}


error() {
    printf '%s\n' "$1" >&2
    exit 1
}

log() {
    if test "${V}" -gt 0; then
	printf "Log: %s\n" "$1" >&2
    fi
}

usage() {
    printf "Usage: %s ...
\t\t -e cloudflare_email (\$USER_EMAIL)
\t\t -d data_directory   (\$DATA_DIR)
\t\t -n name_of_worker   (\$SCRIPT_NAME)
\t\t -v show logs        (\$V) [optional] \n\n" \
	   "$(basename "$0")" >&2 

    printf "SYNOPSIS
\tUpload contents of \$DATA_DIR (default %s) to cloudflare workers
\tas Static Assets. Upload static websites, plain HTML or any other files and
\tserve them via HTTP with cloudflare workers.
\tSame as \`wrangler deploy\` but without the bloat. Header and Redirect
\tsettings can be set in the files \`_headers\` and \`_redirects\` in the
\tsame folder as the script. \n\n" \
	   "$(realpath "${DATA_DIR}")"

    printf "Significant Environment Variables:
\tUSER_EMAIL          Email Associated with Cloudflare (same as -e)
\tDATA_DIR            Directory of static files to upload (same as -d)
\tSCRIPT_NAME         Name of script/worker/page for use in URL etc.
\tHTML_HANDLING       Setting value for html_handling pertaining to management
\t                    of trailing slashes. Same as Cloudflare documentation.
\t                    (same as -n)
\tCFLARE_API_KEY      Cloudflare API Key or API Token
\tCFLARE_ACCOUNT_ID   Cloudflare account ID. If not provided, ID of first
\t                    account associated with USER_EMAIL and CFLARE_API_KEY
\t                    is automatically fetched and used.
\tTMPDIR              Directory for temporary files, default is \$(mktemp -d),
\t                    /tmp/%s or current directory in order.
\t                    Must have write access to this directory.
\tV                   Verbose output if V=1 (same as -v)


UNSAFE ENVIRONMENT VARIABLES:
\tHASHER                 Command-string or shell function to provide when a
\t                       suitable hash utility (sha256sum, openssl) is not found
\t                       in PATH. Script will ask you to set this variable if
\t                       needed.
\t                       (NOT RECOMMENDED).

\tCURLFLAGS              Additional flags to pass into every curl invocation.
\t                       May be useful for configuring proxies etc.
\t                       Flags changing stdout of curl will break the script.
\t                       Ensure that this value is trusted. Due to word
\t                       splitting constraints, value *MUST NOT* contain quoted
\t                       strings with spaces (ie for setting headers with -H).
" "$(basename "$0")" >&2

    exit 1
}

ensure_exists() {
    if ! command -v "$1" >&- 2>&-; then
	printf "Could not find command %s, exiting!\n" "$1" >&2
    fi
}

ensure_email() {
    if test -z "${USER_EMAIL}"; then
	error "One of -e or env var USER_EMAIL is required!"
    fi
}

ensure_scriptname() {
    if test -z "${SCRIPT_NAME}"; then
	error "One of -n or env var SCRIPT_NAME is required!"
    fi
}

# Existence and non-emptiness
ensure_datadir() {
    if ! test -d "${DATA_DIR}"; then
	error "Expected content directory at path $(realpath "${DATA_DIR}") doesn't exist."
    fi

    if test -z "$(ls -A "${DATA_DIR}")"; then
	error "Refusing to upload empty directory! $(realpath "${DATA_DIR}")"
    fi
    printf "Uploading directory %s\n" "$(realpath "${DATA_DIR}")"
}

ensure_hasher() {
    if test -z "${HASHER}"; then
	if command -v sha256sum >&- 2>&-; then
	    log "Using sha256sum as hasher! "
	    HASHER="sha256sum"
	elif command -v openssl >&- 2>&-; then
	    log "Using openssl as hasher! "
	    HASHER="openssl dgst -r -sha256 -hex"
	else
	    # Using single quote intentionally, don't want shell expansion
	    # in this string.
	    # Telling shelleck to not complain.
	    # shellcheck disable=2016
	    printf "%s\n" 'Uh-Oh!
A hash utility could not be found! Hashes are required by the cloudflare API.
Please make available either of the commands {sha256sum, openssl} (recommneded)
OR
Set the environment variable HASHER to a command that will generate a hash
in the same format as `sha256sum` or `openssl dgst -r -sha256 -hex` when
invoked like so:
    $HASHER <filename>
HASHER will be word-split and could be the name of shell function defined in
your shell. Hash length must be atleast 33 chars. (Not recommended! This option not working will not be a bug.)'
	    exit 2;
	fi # test command -v {sha256sum, openssl}
    
    else # test -z hasher
	set +e # to see if the hasher works, want to print pretty message.
	echo "hasher test" > "${TMPDIR}/.hasher-test"
	test=$(${HASHER} "${TMPDIR}/.hasher-test")
	hasher_code="$?"
	test -f "${TMPDIR}/.hasher-test" && rm "${TMPDIR}/.hasher-test"
	
	if test "${hasher_code}" != 0; then
	    printf "Bad Hasher provided!
Value of HASHER given was \`%s\` which gave non zero return code %d when invoked! \n" \
		   "${HASHER}" "${hasher_code}"
	    exit 2;
	elif # test $? != 0; The len= is part of the "if" started by elif
	    len="$(echo "${test}" | cut -d' ' -f1 | wc -c)";
	    test "${len}" -lt 33; then
		printf "Bad Hasher provided!
Value of HASHER given was \`%s\` which created a hash of length %s when a hash of
length atleast 33 is required! \n" "${HASHER}" "${len}"
		exit 2;
	fi # test $? != 0
	set -e # done with hasher testing, resume hard error on fail error code.
	log "Using user provider HASHER = ${HASHER}"
    fi # test -z hasher
}

# Checks for the 'success' field of the JSON returned by cloudflare.
# They have a habit of returning errors in HTTP 200 so this is the
# only way of knowing. Curl --fail is not super helpful.
cflare_check_error() {
    status=$(echo "$1" | jq -r '.success')
    if test "${status}" != "true" ; then
	error "API error while $2 : $(echo "$1" | jq '.errors' )"
    fi
}

# Retrieve users account ID from email and api key
# There could be multiple accounts so multiple Account IDs
# but only the first is considered.
# User may supply env var if this is an issue.
get_account_id() {
    endpt="${api_base}/accounts"
    # See comment above CURLFLAGS
    # shellcheck disable=2090,2086
    resp=$(
	sf_curl "${endpt}" -H "X-Auth-Email: ${USER_EMAIL}" -H "${authz_hdr}"
	) 

    cflare_check_error "${resp}" "fetching Account ID (API token permissions?)"

    ACCOUNT_ID="$(echo "${resp}" | jq -r '.result[0].id')"
    
    log "Fetched Account ID ${ACCOUNT_ID}"
}

# Populate global variable `manifest` with the "file upload manifest"
# json object.
# Global var cause no convenient returning of values in posix sh
# Update: Future functions just use stdout for returning values.
# Manifest being global is also helpful for hash_to_filename
populate_manifest() {
    # Posix globbing doesn't recurse nested dirs for files
    # TODO: Add ability to ignore files.
    files="$(find "${DATA_DIR}" -type f )"
    log "Found $(echo "${files}" | wc -l) files to upload"
    for f in ${files}; do
	log "Processing file ${f}"

	# the file name has to be in the form of the http route
	# ie ./public/index.html --> /index.html
	fname="${f#"${DATA_DIR}"}"
	# cLoudflare is incompetent
	# hash size 32 breaks their api
	# even tho thats the max size
	# UPDATE: <2025-08-04 Mon>
	# Size 31 hashes ALSO break their API but without warning or error
	# You need to give it size 33, otherwise it will deploy but give
	# http500 when requested from the subdomain after everything is done!
	# Thats what Wrangler does.
	# SIZE OF HASH IS INCREDIBLY LOAD BEARING!!
	hash="$(${HASHER} "${f}" | cut -d' ' -f1 | cut -c1-32)"
	size="$(wc -c < "${f}")"
	# Maybe figure how to combine these into one sometime...
	manifest=$( echo "${manifest}" | jq ".manifest.\"${fname}\".hash=\"${hash}\"" )
	manifest=$( echo "${manifest}" | jq ".manifest.\"${fname}\".size=${size}" )
    done

    log "Created manifest:"
    log "$(echo "${manifest}" | jq -c)"

    # echo "${manifest}" | jq > ./manifest

}
# $1: 3̸1̸ 3̸2̸ 3̸3̸ ??? char hash
# Stdout: Name of file matching hash, or 'null'
# Probably should do some error checking here,
# even tho all hashes must have a corresponding filename
# but then again cloudflare is incredibly incompetent
hash_to_filename() {
    echo "${manifest}" |
	# Search for object with key hash matching first arg.
	# Then get the 0th key
	# There should only be one key.
	jq -r ".manifest | map_values(select(.hash==\"$1\")) | keys[0] | @sh" |
	tr -d "'"
}

# $1: Response from Cflare, checked by caller.
# Stdout: Final result object with completion JWT
do_upload() {
    upload_token="$(echo "$1" | jq '.result.jwt' | tr -d "\"")"

    # If all assets exist, buckets will be empty and uploading
    # must be skipped.
    # In this case, the response from uploading the manifest
    # already has the completion JWT
    num=$(echo "$1" | jq -r '.result.buckets | length')
    if test "${num}" -eq 0; then
	log "No assets to upload!"
	echo "$1"
    else
	# Begin the pipeline
	# What happens in the pipeline stays in the pipeline!!
	# i.e. Its in a subshell, variable assignments wont propogate.
	# DO NOT add random stuff after the | otherwise the pipeline will
	# break.
	echo "$1" |
	    # Iterate over the buckets array line by line, formart for shells
	    jq -r '.result.buckets | .[] | @sh' |
	    # Remove single quote char inserted by jq
	    tr -d "'" |
	    # Loop over each line, store line contents in variable bucket
	    while read -r bucket; do
		log "Processing bucket ${bucket}"
		# One Curl invocation per bucket
		curlflags=""
		# For each hash in the bucket, prepare curl -F flag string
		for hashed in ${bucket}; do
		    # Lookup hash in manifest json
		    # Who said PosixSH can't have datastructures?
		    name="$(hash_to_filename "${hashed}")"
		    b64="$(base64 "${DATA_DIR}/${name}" | tr -d '\n')"
		    
		    # Cloudflare is evil and stupid
		    # APIDocs page is lies and deceit
		    # The base64 needs to be in quotes
		    # Even though in the protocol its send as the BODY of the req.
		    # Do they even know what multipart/form-data actually is?
		    # shell check is mad cause the escaped qoutes in the string
		    # are directly given to the command.
		    # But it works so idc.
		    # See comment above CURLFLAGS
		    # shellcheck disable=2089
		    curlflags="${curlflags} -F ${hashed}=\"${b64}\""
		done
		# need ?base64=true
		endpt="${api_base}/accounts/${ACCOUNT_ID}/workers/assets/upload?base64=true"

		# See comment above CURLFLAGS
		# shellcheck disable=2086,2090
		# For this endpoint, Authz header MUST be the JWT, not API key.
		res_tmp=$(sf_curl "${endpt}" \
			       -H "Authorization: Bearer ${upload_token}" \
			       -H "X-Auth-Key: ${CFLARE_API_KEY}" \
			       -H "X-Auth-Email: ${USER_EMAIL}" \
			       ${curlflags})
		# Clownflare likes to return error JSONS in HTTP 200 Responses...
		cflare_check_error "${res_tmp}" \
				   "uploading bucket ${bucket}: ${curlflags}"
		# Disgusting hack
		# Continuosly overwrite the file so the last value can be
		# recovered outside the pipeline.
		printf "%s" "${res_tmp}" > "${TMPDIR}/.shellflare-tmp"
	    done
	final_res="$(cat "${TMPDIR}/.shellflare-tmp")"
	rm "${TMPDIR}/.shellflare-tmp"
	log "$(echo "${final_res}" | jq -c)"
	# this is the "return value" of the function.
	echo "${final_res}" | jq -c
    fi
}

# Uploads `manifest` to cflare
# Result sent to stdout.
# Result may be error
upload_manifest() {
    endpt="${api_base}/accounts/${ACCOUNT_ID:?}/workers/scripts/${SCRIPT_NAME:?}/assets-upload-session"

    sf_curl -X "POST" "${endpt}" -H "Content-Type: application/json" \
	 -H "${authz_hdr}" \
	 -H "X-Auth-Email: ${USER_EMAIL}" \
	 -d "$(echo "${manifest}" | jq -c)"
}

# $1: Result object after uploading all files.
finalize_worker() {
    token="$(echo "$1" | jq -r '.result.jwt' | tr -d "\"")"

    comp_date="$(date +%F)"

    md=$(jq -n -r ".assets.jwt=\"${token}\"")
    md=$(echo "${md}" | jq -r ".assets.config={}")
    md=$(echo "${md}" | jq -r ".assets.config.html_handling=\"drop-trailing-slash\"")
    md=$(echo "${md}" | jq -r ".compatibility_date=\"${comp_date}\"")
    md=$(echo "${md}" | jq -r ".compatibility_flags=[]")

    if test -s "./_headers"; then
	log "Including headers from $(realpath ./_headers)"
	hdrs="$(cat ./_headers)"
	md=$(echo "${md}" | jq -r ".assets.config._headers=\"${hdrs}\"")
    fi

    if test -s "./_redirects"; then
	log "Including redirects from $(realpath ./_redirects)"
	rdrs="$(cat ./_redirects)"
	md=$(echo "${md}" | jq -r ".assets.config._redirects=\"${rdrs}\"")
    fi

    # excludeScript is an undocumented option found courtesy running
    # MITMProxy on wrangler.
    endpt="${api_base}/accounts/${ACCOUNT_ID}/workers/scripts/${SCRIPT_NAME}?excludeScript=true"

    # See comment above CURLFLAGS
    # this too probably shouldn't work.
    # shellcheck disable=2090,2086
    res=$(sf_curl -X "PUT" "${endpt}" -H "${authz_hdr}" \
	 -F metadata="$(echo "${md}" | jq -c)")

    log "Deployment result: $(echo "${res}" | jq -c)"

    cflare_check_error "${res}" "finalizing deployment"
    
    printf "Upload succesful! Created new deployment with ID %s\n" \
	   "$(echo "${res}" | jq -r '.result.deployment_id')"

}

# Main entrypoint
main() {
    # There are other commands used, but they are POSIX required/in coreutils
    # If user doesn't have those they have bigger concerns than cloudflare API.
    ensure_exists "curl"
    ensure_exists "jq"

    ensure_hasher

    # If there are no args this loop will simply not run.
    while getopts "hve:d:n:" "args"; do
	  case "${args}" in
	      e) USER_EMAIL="${OPTARG}";;
	      d) DATA_DIR="${OPTARG}";;
	      n) SCRIPT_NAME="${OPTARG}";;
	      v) V=1;;
	      h) usage;;
	      *) usage;;
	  esac
    done

    # Not making this a CLI arg for security or something
    # Perhaps there should be a read-a-file option?
    if test -z "${CFLARE_API_KEY}"; then
	error "Expected Cloudflare API key in env var CFLARE_API_KEY"
    fi

    authz_hdr="Authorization: Bearer ${CFLARE_API_KEY}"

    ensure_email
    ensure_datadir
    ensure_scriptname

    if test -z "${TMPDIR}"; then
	if command -v "mktemp" >&- 2>&-; then
	    TMPDIR="$(mktemp -d)"
	elif test -d "/tmp"; then
	    mkdir -p "/tmp/$(basename "$0")"
	    TMPDIR="/tmp/shellflare"
	else
	    TMPDIR="${PWD}"
	fi
    fi
    log "Using Temp Dir: ${TMPDIR}"


    # Fetch first account ID given by API for Token+Email
    # User can invoke with variable set to use a different one.
    # Perhaps add this to the CLI too?
    if test -z "${ACCOUNT_ID}"; then
	get_account_id
    else
	log "Using Account ID from Environment: ${ACCOUNT_ID}"
    fi

    if test "${ACCOUNT_ID}" = "no"; then
	error "Failed to get account ID"
    fi

    # Sets global var `manifest`
    # Create upload manifest with hashes and sizes.
    populate_manifest

    # Upload manifest, get upload JWT
    manifest_response="$(upload_manifest)"

    log "Manifest Response: $(echo "${manifest_response}" | jq -c)"

    cflare_check_error "${manifest_response}" "uploading manifest"

    # Upload using JWT, get completion JWT
    final_res=$(do_upload "${manifest_response}")

    # echo "Up${final_res}"
    log "File upload result: $(echo "${final_res}" | jq -c)"

    cflare_check_error "${final_res}" "uploading assets"

    # Deploy worker by redeeming completion JWT
    finalize_worker "${final_res}"

	      
}

# Detect if sourced
# Do not invoke main if sourced
# Courtesy: Claude AI
case ${0##*/} in
    sh|dash|bash|ksh|zsh)
	echo "Sourced";
        ;;
    *)
	# This $@ is important cause getopts is called in main.
	main "$@";
        ;;
esac
